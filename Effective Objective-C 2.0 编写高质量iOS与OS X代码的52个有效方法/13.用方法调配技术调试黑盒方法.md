# 用“方法调配技术”调试“黑盒方法”
> 方法调配（method swizzling）：在运行期，通过使用与给定的选择子名称相对应的方法，可以替换旧方法，让新功能在类的所有实例中生效。

1. 类的方法列表会把选择子的名称映射到相关的方法实现上，使得动态消息派发系统能够据此找到应该调用的方法。
2. 方法均以函数指针的形式表示，指针叫做IMP
	
		id (*IMP)(id, SEL, ...)

3. 在某个类的方法映射表中，只要修改表的布局，就能反映到所有该类的实例上。
4. 一般是为已有方法添加新功能，通过方法交换，来实现新功能。
5. 方法交换一般发生在`load`里面。
5. 应用场景：
	* 调试程序时，为那些完全不知道具体实现的黑盒方法添加日志记录功能


	* 一个方法更改全局字体
	* 一个方法更改UI（新版UI切图）

```
//两个方法Method进行交换
OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) 

//获取方法 Method
OBJC_EXPORT Method class_getInstanceMethod(Class cls, SEL name)

```

##总结：
***1. 在运行期，可以向类中新增或替换选择子所对应的方法实现***

***2. 使用另一份实现来替换原有的方法实现，叫“方法调配”，可以使用此技术向原有实现中添加新功能***

***3. 一般只有在调试程序时才需要在运行期修改方法实现，谨而慎之，不以滥用***




