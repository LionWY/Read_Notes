# 用handler块降低代码分散程度

1. 异步执行任务：处理用户界面的显示及触摸操作所用的线程（主线程），不会因为要执行I/O或网络通信这类耗时的任务而阻塞。

2. 同步执行任务：会使应用程序在一定时间内无响应，程序就会自动终止，因为：

	* iOS系统的“系统监控器”（system watchdog）在发现某个应用程序的主线程已经阻塞一段时间之后，就会令其终止

3. 异步执行任务，通常会使用`block`或者`delegate`。

## block or delegate

1. 使用block的好处：
	* 代码更清晰，紧凑，整洁，回调方法的代码跟启动任务的代码放在一起

	* 块声明在创建获取器的范围里，所以它可以访问此范围内的全部变量


2. delegate的缺点：
	* 如果类要分别使用多个获取器下载不同数据，就需要在回调方法中，并根据传入的获取器参数来切换

	* 而要在回调方法中进行判断，就需要把获取器对象声明为实例变量，即全局变量

3. 在处理返回结果时如果把操作成功和操作失败分成两个block，代码清晰易懂。

4. 如果全放在一个block里面，需要传入`error`参数，来进行判断是否成功。
	
	* 坏处是：代码可能会比较复杂，并且很长。
	
	* 好处是：更为灵活：
	
		* 在传入错误信息时，可以把数据也传进来

		* 调用API的代码可能会在处理成功响应的过程中发现错误

5. block 可用于多线程中，让代码运行在特定的线程上 		
6. 一些参考资料	

	* [Blocks or Delegates](http://blog.stablekernel.com/blocks-or-delegates/)(英文)
	* [开发该选择Blocks还是Delegates](http://www.cocoachina.com/ios/20150927/13525.html)（翻译中文

## 总结：

***1. 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明***

***2. 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块实现，则可直接将块与相关对象放在一起***

***3. 设计API时如果用到了handler块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行***





